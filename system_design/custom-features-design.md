# 定制化功能设计方案
> 相较于复现烂大街的RAG的解决方案，侧重实现运维定制化功能才是比赛的重点。本文档详细阐述了如何实现竞赛要求中的各项高度定制化与创新性功能。

## 1. 混合检索（Hybrid Search）

**目标**：结合关键字检索（如BM25）的精确匹配能力和向量检索的语义理解能力，提高检索召回率和精准度，尤其是在处理包含专业术语和型号的查询时。

**实现策略**：

1.  **并行检索**：当用户提问时，系统将查询同时发往两个并行的检索器：
    *   **向量检索器**：使用 `BGE-large-zh` 模型将查询转换为向量，在阿里云OpenSearch/DashVector中进行语义相似度搜索。
    *   **关键字检索器**：使用经典的BM25算法对查询进行分词，在知识库的文本索引中进行关键字匹配。大部分现代向量数据库（包括OpenSearch）都原生支持BM25或稀疏向量检索。

2.  **结果融合与重排序（Reranking）**：
    *   从两个检索器分别获取Top-K个结果文档块（Chunks）。
    *   采用**倒数排名融合（Reciprocal Rank Fusion, RRF）** 算法对两组结果进行合并和重排序。RRF算法会给每个被检索到的文档一个分数，分数与其在不同检索结果列表中的排名的倒数成正比，然后将分数相加得到最终排名。
    *   **LangChain集成**：可以利用 `LangChain` 的 `EnsembleRetriever` 类来轻松实现此功能。该类可以包装多个不同的检索器（一个向量检索器，一个BM25检索器），并自动处理结果的融合。

3.  **将最终结果送入大模型**：经过重排序后的、最相关的文档片段列表将被送入Qwen模型，作为生成答案的上下文。

**关联API**：
*   混合检索作为核心的后端能力，其执行被封装在其他业务API调用中，主要体现在 `POST /cases/{caseId}/interactions` 接口。调用此接口时，可以通过可选参数 `retrievalWeight` 来调整混合检索中语义检索与关键词检索的权重。

<br>

## 2. 知识自进化（带反馈的闭环系统）

**目标**：建立一个用户反馈机制，允许将经过验证的、高质量的问答对或解决方案沉淀回知识库，使系统能够持续学习和成长。

**实现策略**：

1.  **前端反馈界面**：在每个生成的答案旁边，提供明确的反馈按钮，如“👍 满意”、“👎 不满意”，以及一个“编辑并提交正确答案”的文本框。

2.  **后端反馈API**：创建一个API端点（`POST /cases/{caseId}/feedback`），用于接收前端提交的反馈数据。数据应包含：原始问题、模型生成的答案、用户评分、用户修正后的答案（如果有）以及相关的会话ID。

3.  **反馈数据暂存**：将收集到的反馈信息存储在后端数据库（MySQL）的一个专门的 `feedback` 表中，并标记状态为“待审核”。

4.  **人工审核与标注**：定期对“待审核”的反馈进行人工审查。对于有价值的反馈（例如一个被用户验证为正确的、全新的解决方案），审核员将其改写、标注为一篇高质量的知识文档（例如Markdown格式）。

5.  **知识入库自动化**：
    *   将审核通过的知识文档上传至专门用于存放“已验证知识”的OSS Bucket目录中。
    *   利用**函数计算（FC）的OSS触发器**，自动触发知识处理流水线：新文档上传 → 自动切片 → 调用BGE模型进行向量化 → 存入向量数据库。
    *   至此，新的知识就可被未来的用户查询所检索到，完成整个闭环。

**关联API**：
*   **`POST /cases/{caseId}/feedback`**: 用户通过此接口提交对整个诊断案例的最终反馈，包括评价（`solved` / `unsolved`）和修正后的解决方案。这是知识自进化流程的起点。

<br>

## 3. 大模型Agent能力（主动提问与多轮对话）

**目标**：当用户输入的问题信息不足或模糊时，系统能像专家一样主动发起追问，引导用户提供关键信息，最终完成任务。

**实现策略**：利用 `langgraph` 构建一个基于状态机的多轮对话智能体（Agent）。

1.  **定义状态机**：`langgraph` 的核心是图（Graph），每个节点（Node）代表一个处理步骤，每条边（Edge）代表状态的流转。我们需要定义一个包含问题、聊天记录、是否需要补充信息等字段的状态（State）。

2.  **入口分析节点（Analyze Query Node）**：
    *   这是图的入口。该节点调用一次大模型（Qwen）。
    *   **Prompt设计**：精心设计Prompt，要求模型判断：“仅根据当前对话历史和问题，信息是否足以进行根因分析？如果不能，请明确提出需要用户补充的关键信息（例如：‘请提供设备的具体型号’、‘请执行`show ip interface brief`并贴出回显’），并生成一个向用户提问的句子。”

3.  **条件判断边（Conditional Edge）**：
    *   这是图的决策点。它检查分析节点的输出。
    *   如果模型认为信息**足够**，则将流程导向“RAG检索节点”。
    *   如果模型认为信息**不足**，则将流程导向“追问用户节点”。

4.  **追问用户节点（Ask User Node）**：该节点将模型生成的追问问题通过API返回给前端展示。系统进入等待用户输入的状态。

5.  **循环与状态更新**：用户提供补充信息后，该信息被更新到对话状态的聊天记录中，流程重新回到“入口分析节点”，形成一个循环，直到信息收集充分为止。

**关联API**：
*   **`POST /cases`**: 当用户发起第一次提问时，调用此接口创建新的诊断案例（Case）和初始的对话图（包含用户问题节点和AI的首次分析节点）。
*   **`POST /cases/{caseId}/interactions`**: 在后续的每一轮交互中，用户通过此接口提交补充信息。后端Agent根据新信息驱动状态机，返回新增的节点（可能是AI的进一步追问，也可能是最终解决方案）。
*   **`GET /cases/{caseId}`**: 用于获取整个案例的完整对话历史和图谱结构。

<br>

## 4. 跨厂商解决方案生成

**目标**：系统能识别问题的上下文涉及哪家网络设备厂商（如华为、思科），并生成符合该厂商命令行语法的解决方案。

**实现策略**：

1.  **知识库预处理**：在构建知识库时，为所有文档片段（Chunks）打上元数据（Metadata）标签。例如，从华为手册中提取的知识，其元数据应包含 `{"vendor": "huawei"}`；思科的则为 `{"vendor": "cisco"}`。

2.  **厂商意图识别**：
    *   **Agent追问**：在上一节的Agent流程中，如果上下文中没有厂商信息，可以增加一个追问：“请问您操作的设备是华为、思科还是其他厂商？”
    *   **关键词推断**：通过问题中出现的关键词（如`display` vs `show`，`VRP` vs `IOS`）来初步推断厂商。

3.  **元数据过滤检索**：在执行RAG检索时，使用已识别出的厂商信息对向量数据库进行**元数据过滤**。例如，如果识别出是华为，则只在 `{"vendor": "huawei"}` 的文档片段中进行搜索。`LangChain`的检索器完美支持此功能。

4.  **上下文指令注入（Prompt Engineering）**：在最后调用大模型生成答案的Prompt中，明确注入厂商指令。例如：
    > “你是一位资深的华为网络专家。请严格根据以下上下文信息，使用华为VRP系统的命令语法，为用户提供解决方案：[...检索到的华为文档...]”

**关联API**：
*   **`POST /cases/{caseId}/interactions`**: 在调用此接口时，可以在请求体中通过 `filterTags` 参数传入明确的厂商标识（如 `["Huawei"]`），从而在后端进行精确的元数据过滤检索。
*   **`GET /cases/{caseId}/nodes/{nodeId}/commands`**: 如果返回的解决方案节点（Node）中包含了具体操作命令，可以通过此接口获取与该节点关联的、按厂商分类的命令列表。

<br>

## 5. 结果可解释性（高亮引用来源）

**目标**：在生成的答案中，明确标注出每一句话或关键信息来源于哪篇原始文档的哪个部分，增加答案的可信度和可追溯性。

**实现策略**：

1.  **检索时返回元数据**：确保RAG检索器在返回文档片段内容的同时，也返回其完整的元数据，至少包含：`source_document_name`（源文件名）、`page_number`（页码）、`chunk_id`（片段ID）。

2.  **强制模型引用**：使用 `LangChain` 提供的 `create_citation_chain` 或类似技术。在调用大模型生成答案的Prompt中，强制要求模型在生成内容时，必须在引用了上下文信息的地方，带上如 `[doc1]`、`[doc2]` 这样的引用标记。

3.  **结构化API响应**：改造后端API的返回格式。不要只返回一个字符串，而应返回一个JSON对象，包含两部分：
    ```json
    {
      "answer": "为解决OSPF邻居ExStart状态问题，您需要检查接口的MTU值 [doc1]。在华为设备上，可以使用命令 `display ip interface brief` 来查看 [doc2]。",
      "sources": [
        { "id": "doc1", "file": "HUAWEI-OSPF故障排查手册.pdf", "page": 25 },
        { "id": "doc2", "file": "华为VRP命令参考.pdf", "page": 112 }
      ]
    }
    ```

4.  **前端高亮展示**：前端应用解析这个JSON。在显示 `answer` 文本时，将 `[doc1]` 等引用标记渲染成可点击的标签。当用户鼠标悬浮或点击该标签时，弹出一个卡片，显示 `sources` 数组中对应ID的来源信息（文件名和页码），甚至可以链接到原文。 

**关联API**：
*   **`GET /cases/{caseId}/nodes/{nodeId}`**: 当用户点击某个解决方案节点查看详情时，调用此接口。其返回的 `Node` 对象的 `content` 字段中，就包含了带有引用标记的 `answer` 文本和 `sources` 数组，前端可直接用于渲染。
*   **`GET /cases/{caseId}/nodes/{nodeId}/knowledge`**: 除了在答案中高亮，系统还可以提供一个专门的“知识溯源”功能。调用此接口可以获取生成该节点（Node）时所引用的所有知识库文档片段及其相似度分数，提供更深层次的可解释性。 